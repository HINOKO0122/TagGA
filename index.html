<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>GA Tag Simulation - 4-Direction Grid Mode</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; }
        .controls { padding: 20px; text-align: center; background: #333; width: 100%; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 20px; }
        canvas { background: #000; border: 1px solid #555; width: 150px; height: 150px; }
        button { cursor: pointer; padding: 8px 15px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 4px; }
        button:hover { background: #555; }
        #info { font-size: 1.2em; margin: 10px; font-family: monospace; color: #0f0; }
        input { padding: 8px; width: 200px; background: #111; color: #ccc; border: 1px solid #444; }
    </style>
</head>
<body>
    <div class="controls">
        <h1>GA 鬼ごっこ (上下左右限定ver)</h1>
        <div id="info">世代: 0 | 待機中</div>
        <button id="startBtn">リセットして開始</button>
        <button id="playerChaserBtn">鬼として参戦</button>
        <button id="playerEvaderBtn">逃走者として参戦</button>
        <p style="font-size: 0.8em; color: #aaa;">操作: 矢印キー または WASD で方向転換 / スペースキーでワープ</p>
    </div>
    <div id="container"></div>

    <script>
    const ROOM_SIZE = 200;
    const SIM_COUNT = 25;
    const DURATION_SEC = 10;
    const FPS = 30;
    const TOTAL_FRAMES = DURATION_SEC * FPS;
    // DNA入力を調整 (位置x2, 相手位置x2, 向きx4, クールダウンx1, 残り時間x1 = 10入力)
    const DNA_LENGTH = 10 * 4; 

    class Agent {
        constructor(x, y, dna) {
            this.x = x; this.y = y;
            // 0:右, 1:下, 2:左, 3:上
            this.dirIndex = Math.floor(Math.random() * 4);
            this.warpCooldown = 0;
            this.dna = dna || Array.from({ length: DNA_LENGTH }, () => Math.random() * 2 - 1);
            this.score = 0;
            this.isAlive = true;
            this.warpLines = [];
        }
        get angle() { return this.dirIndex * (Math.PI / 2); }
    }

    class Simulation {
        constructor(container, chaserDNA, evaderDNA) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = ROOM_SIZE;
            this.canvas.height = ROOM_SIZE;
            container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.chaser = new Agent(20, 20, chaserDNA);
            this.evader = new Agent(180, 180, evaderDNA);
            this.frame = 0;
            this.isPlayerMode = false;
            this.playerRole = null;
        }

        update(keys) {
            if (!this.chaser.isAlive || this.frame >= TOTAL_FRAMES) return;

            [this.chaser, this.evader].forEach((ent, idx) => {
                const isChaser = idx === 0;
                const target = isChaser ? this.evader : this.chaser;
                let moveCmd = { newDir: ent.dirIndex, warp: false };

                ent.warpLines = ent.warpLines.filter(line => { line.life--; return line.life > 0; });

                if (this.isPlayerMode && this.playerRole === (isChaser ? 'chaser' : 'evader')) {
                    if (keys.has('arrowright') || keys.has('d')) moveCmd.newDir = 0;
                    else if (keys.has('arrowdown') || keys.has('s')) moveCmd.newDir = 1;
                    else if (keys.has('arrowleft') || keys.has('a')) moveCmd.newDir = 2;
                    else if (keys.has('arrowup') || keys.has('w')) moveCmd.newDir = 3;
                    moveCmd.warp = keys.has(' ');
                } else {
                    // AI入力: 自分の位置、相手の位置、現在の向き(One-hot)、ワープ可否、残り時間
                    const dirFlags = [0,0,0,0]; dirFlags[ent.dirIndex] = 1;
                    const inputs = [
                        ent.x/200, ent.y/200, 
                        target.x/200, target.y/200, 
                        ...dirFlags,
                        ent.warpCooldown === 0 ? 1 : 0,
                        (TOTAL_FRAMES-this.frame)/TOTAL_FRAMES
                    ];
                    
                    let outputs = [0, 0, 0, 0]; // 0-3: 各方向への重み, 4: ワープ
                    for(let i=0; i<4; i++) {
                        for(let j=0; j<10; j++) outputs[i] += inputs[j] * ent.dna[i*10 + j];
                    }
                    // 最も数値が高い方向を向く
                    moveCmd.newDir = outputs.indexOf(Math.max(...outputs.slice(0, 4)));
                    // 4番目の出力をワープ判定に使う（簡易化のため最初のDNAの合計などを利用）
                    moveCmd.warp = outputs.reduce((a,b)=>a+b) > 2.0; 
                }

                ent.dirIndex = moveCmd.newDir;
                const speed = 5;
                
                if (moveCmd.warp && ent.warpCooldown === 0) {
                    const oldX = ent.x; const oldY = ent.y;
                    const dist = 60;
                    ent.x += Math.cos(ent.angle) * dist;
                    ent.y += Math.sin(ent.angle) * dist;
                    ent.warpCooldown = 25;
                    ent.warpLines.push({ x1: oldX, y1: oldY, x2: ent.x, y2: ent.y, life: 20 });
                } else {
                    ent.x += Math.cos(ent.angle) * speed;
                    ent.y += Math.sin(ent.angle) * speed;
                }

                ent.x = Math.max(5, Math.min(ROOM_SIZE-5, ent.x));
                ent.y = Math.max(5, Math.min(ROOM_SIZE-5, ent.y));
                if (ent.warpCooldown > 0) ent.warpCooldown--;
            });

            const dist = Math.hypot(this.chaser.x - this.evader.x, this.chaser.y - this.evader.y);
            if (dist < 12) {
                this.chaser.isAlive = false;
                this.chaser.score = 3000 + (TOTAL_FRAMES - this.frame);
                this.evader.score = this.frame;
            }
            this.frame++;
            if (this.frame >= TOTAL_FRAMES && this.chaser.isAlive) {
                this.chaser.score = Math.max(0, 500 - dist);
                this.evader.score = 1000 + dist;
            }
            this.draw();
        }

        draw() {
            const ctx = this.ctx;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);

            [this.chaser, this.evader].forEach((ent, idx) => {
                const color = idx === 0 ? '#ff4444' : '#00ffff';
                
                ent.warpLines.forEach(line => {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255, 255, 0, ${line.life / 20})`;
                    ctx.lineWidth = 3;
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                    ctx.stroke();
                });

                ctx.fillStyle = color;
                // 向きがわかるように少し長く描画
                ctx.save();
                ctx.translate(ent.x, ent.y);
                ctx.rotate(ent.angle);
                ctx.fillRect(-5, -5, 12, 10); // 前方が少し長い
                if (ent.warpCooldown === 0) {
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(-7, -7, 14, 14);
                }
                ctx.restore();
            });

            if (!this.chaser.isAlive) {
                ctx.strokeStyle = 'white';
                ctx.strokeRect(0,0, ROOM_SIZE, ROOM_SIZE);
            }
        }
    }

    let simulations = [];
    let generation = 0;
    const keys = new Set();
    const container = document.getElementById('container');
    const infoDisp = document.getElementById('info');

    window.addEventListener('keydown', e => keys.add(e.key.toLowerCase()));
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    function startGeneration(isNew = false) {
        let nextChaserDNAs = [];
        let nextEvaderDNAs = [];

        if (!isNew && simulations.length > 0) {
            const sortedC = simulations.map(s => s.chaser).sort((a,b) => b.score - a.score);
            const sortedE = simulations.map(s => s.evader).sort((a,b) => b.score - a.score);
            for(let i=0; i<SIM_COUNT; i++) {
                const pC = sortedC[Math.floor(Math.random()*5)].dna;
                const pE = sortedE[Math.floor(Math.random()*5)].dna;
                nextChaserDNAs.push(pC.map(v => v + (Math.random()*0.5 - 0.25)));
                nextEvaderDNAs.push(pE.map(v => v + (Math.random()*0.5 - 0.25)));
            }
            generation++;
        } else {
            generation = 1;
        }

        container.innerHTML = '';
        simulations = [];
        for (let i = 0; i < SIM_COUNT; i++) {
            simulations.push(new Simulation(container, nextChaserDNAs[i], nextEvaderDNAs[i]));
        }
    }

    function loop() {
        if (simulations.length > 0) {
            simulations.forEach(sim => sim.update(keys));
            const main = simulations[0];
            infoDisp.innerText = `世代: ${generation} | 残り時間: ${(Math.max(0, (TOTAL_FRAMES-main.frame)/FPS)).toFixed(1)}s`;
            if (simulations.every(s => s.frame >= TOTAL_FRAMES || !s.chaser.isAlive)) {
                if (!simulations[0].isPlayerMode) startGeneration();
                else infoDisp.innerText = `世代: ${generation} | 終了`;
            }
        }
        requestAnimationFrame(loop);
    }

    document.getElementById('startBtn').onclick = () => startGeneration(true);
    document.getElementById('playerChaserBtn').onclick = () => {
        startGeneration(false);
        simulations[0].isPlayerMode = true;
        simulations[0].playerRole = 'chaser';
        simulations[0].canvas.style.outline = "2px solid red";
    };
    document.getElementById('playerEvaderBtn').onclick = () => {
        startGeneration(false);
        simulations[0].isPlayerMode = true;
        simulations[0].playerRole = 'evader';
        simulations[0].canvas.style.outline = "2px solid #0ff";
    };

    startGeneration(true);
    loop();
    </script>
</body>
</html>
