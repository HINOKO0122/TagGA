<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>GA Tag Simulation - High Warp Version</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; }
        .controls { padding: 20px; text-align: center; background: #333; width: 100%; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 20px; }
        canvas { background: #000; border: 1px solid #555; width: 150px; height: 150px; }
        button { cursor: pointer; padding: 8px 15px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 4px; }
        button:hover { background: #555; }
        #info { font-size: 1.2em; margin: 10px; font-family: monospace; color: #0f0; }
        input { padding: 8px; width: 200px; background: #111; color: #ccc; border: 1px solid #444; }
    </style>
</head>
<body>
    <div class="controls">
        <h1>GA 鬼ごっこ (ワープ強化ver)</h1>
        <div id="info">世代: 0 | 待機中</div>
        <button id="startBtn">リセットして開始</button>
        <button id="playerChaserBtn">鬼として参戦</button>
        <button id="playerEvaderBtn">逃走者として参戦</button>
        <div>
            <input type="text" id="ioField" placeholder="JSONデータ">
            <button id="exportBtn">データ出力</button>
            <button id="importBtn">データ読込</button>
        </div>
    </div>
    <div id="container"></div>

    <script>
    const ROOM_SIZE = 200;
    const SIM_COUNT = 25;
    const DURATION_SEC = 10;
    const FPS = 30;
    const TOTAL_FRAMES = DURATION_SEC * FPS;
    const DNA_LENGTH = 21; 

    class Agent {
        constructor(x, y, dna) {
            this.x = x; this.y = y;
            this.angle = Math.random() * Math.PI * 2;
            this.warpCooldown = 0;
            this.dna = dna || Array.from({ length: DNA_LENGTH }, () => Math.random() * 2 - 1);
            this.score = 0;
            this.isAlive = true;
            this.warpLines = []; // ワープ軌跡を複数保持できるように
        }
    }

    class Simulation {
        constructor(container, chaserDNA, evaderDNA) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = ROOM_SIZE;
            this.canvas.height = ROOM_SIZE;
            container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.chaser = new Agent(20, 20, chaserDNA);
            this.evader = new Agent(180, 180, evaderDNA);
            this.frame = 0;
            this.isPlayerMode = false;
            this.playerRole = null;
        }

        update(keys) {
            if (!this.chaser.isAlive || this.frame >= TOTAL_FRAMES) return;

            [this.chaser, this.evader].forEach((ent, idx) => {
                const isChaser = idx === 0;
                const target = isChaser ? this.evader : this.chaser;
                let moveCmd = { angleVel: 0, warp: false };

                // ワープ軌跡の寿命を減らす
                ent.warpLines = ent.warpLines.filter(line => {
                    line.life--;
                    return line.life > 0;
                });

                if (this.isPlayerMode && this.playerRole === (isChaser ? 'chaser' : 'evader')) {
                    if (keys.has('a')) moveCmd.angleVel = -0.25;
                    if (keys.has('d')) moveCmd.angleVel = 0.25;
                    moveCmd.warp = keys.has(' ');
                } else {
                    const inputs = [
                        ent.x/200, ent.y/200, 
                        target.x/200, target.y/200, 
                        Math.cos(ent.angle), 
                        ent.warpCooldown === 0 ? 1 : 0, 
                        (TOTAL_FRAMES-this.frame)/TOTAL_FRAMES
                    ];
                    let outputs = [0, 0, 0];
                    for(let i=0; i<3; i++) {
                        for(let j=0; j<7; j++) outputs[i] += inputs[j] * ent.dna[i*7 + j];
                    }
                    moveCmd.angleVel = Math.max(-0.25, Math.min(0.25, outputs[0]));
                    // ワープ判定を甘く (0.8 -> 0.5)
                    moveCmd.warp = outputs[2] > 0.5;
                }

                ent.angle += moveCmd.angleVel;
                
                if (moveCmd.warp && ent.warpCooldown === 0) {
                    const oldX = ent.x;
                    const oldY = ent.y;
                    ent.x += Math.cos(ent.angle) * 60; // 飛距離アップ
                    ent.y += Math.sin(ent.angle) * 60;
                    ent.warpCooldown = 20; // クールダウン短縮
                    ent.warpLines.push({ x1: oldX, y1: oldY, x2: ent.x, y2: ent.y, life: 30 });
                } else {
                    ent.x += Math.cos(ent.angle) * 4.5;
                    ent.y += Math.sin(ent.angle) * 4.5;
                }

                ent.x = Math.max(0, Math.min(ROOM_SIZE, ent.x));
                ent.y = Math.max(0, Math.min(ROOM_SIZE, ent.y));
                if (ent.warpCooldown > 0) ent.warpCooldown--;
            });

            const dist = Math.hypot(this.chaser.x - this.evader.x, this.chaser.y - this.evader.y);
            if (dist < 10) {
                this.chaser.isAlive = false;
                this.chaser.score = 3000 + (TOTAL_FRAMES - this.frame);
                this.evader.score = this.frame;
            }
            this.frame++;
            if (this.frame >= TOTAL_FRAMES && this.chaser.isAlive) {
                this.chaser.score = Math.max(0, 500 - dist);
                this.evader.score = 1000 + dist;
            }
            this.draw();
        }

        draw() {
            const ctx = this.ctx;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);

            [this.chaser, this.evader].forEach((ent, idx) => {
                const color = idx === 0 ? 'red' : '#0ff';
                ent.warpLines.forEach(line => {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255, 255, 0, ${line.life / 30})`; // 徐々に消える
                    ctx.lineWidth = 2;
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                    ctx.stroke();
                });

                ctx.fillStyle = color;
                ctx.fillRect(ent.x-4, ent.y-4, 8, 8);
                
                // ワープ可能時はオーラを表示
                if (ent.warpCooldown === 0) {
                    ctx.strokeStyle = color;
                    ctx.strokeRect(ent.x-6, ent.y-6, 12, 12);
                }
            });

            if (!this.chaser.isAlive) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(0,0, ROOM_SIZE, ROOM_SIZE);
            }
        }
    }

    let simulations = [];
    let generation = 0;
    const keys = new Set();
    const container = document.getElementById('container');
    const infoDisp = document.getElementById('info');

    window.addEventListener('keydown', e => keys.add(e.key.toLowerCase()));
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    function startGeneration(isNew = false) {
        let nextChaserDNAs = [];
        let nextEvaderDNAs = [];

        if (!isNew && simulations.length > 0) {
            const sortedC = simulations.map(s => s.chaser).sort((a,b) => b.score - a.score);
            const sortedE = simulations.map(s => s.evader).sort((a,b) => b.score - a.score);
            for(let i=0; i<SIM_COUNT; i++) {
                const pC = sortedC[Math.floor(Math.random()*5)].dna;
                const pE = sortedE[Math.floor(Math.random()*5)].dna;
                nextChaserDNAs.push(pC.map(v => v + (Math.random()*0.4 - 0.2)));
                nextEvaderDNAs.push(pE.map(v => v + (Math.random()*0.4 - 0.2)));
            }
            generation++;
        } else {
            generation = 1;
        }

        container.innerHTML = '';
        simulations = [];
        for (let i = 0; i < SIM_COUNT; i++) {
            simulations.push(new Simulation(container, nextChaserDNAs[i], nextEvaderDNAs[i]));
        }
    }

    function loop() {
        if (simulations.length > 0) {
            simulations.forEach(sim => sim.update(keys));
            const main = simulations[0];
            infoDisp.innerText = `世代: ${generation} | 残り時間: ${(Math.max(0, (TOTAL_FRAMES-main.frame)/FPS)).toFixed(1)}s`;

            if (simulations.every(s => s.frame >= TOTAL_FRAMES || !s.chaser.isAlive)) {
                if (!simulations[0].isPlayerMode) startGeneration();
                else infoDisp.innerText = `世代: ${generation} | ゲーム終了 (リセットで再開)`;
            }
        }
        requestAnimationFrame(loop);
    }

    document.getElementById('startBtn').onclick = () => startGeneration(true);
    document.getElementById('playerChaserBtn').onclick = () => {
        startGeneration(false);
        simulations[0].isPlayerMode = true;
        simulations[0].playerRole = 'chaser';
        simulations[0].canvas.style.outline = "2px solid red";
    };
    document.getElementById('playerEvaderBtn').onclick = () => {
        startGeneration(false);
        simulations[0].isPlayerMode = true;
        simulations[0].playerRole = 'evader';
        simulations[0].canvas.style.outline = "2px solid #0ff";
    };
    document.getElementById('exportBtn').onclick = () => {
        if (simulations.length === 0) return;
        const data = { c: simulations[0].chaser.dna, e: simulations[0].evader.dna };
        document.getElementById('ioField').value = JSON.stringify(data);
    };
    document.getElementById('importBtn').onclick = () => {
        const val = document.getElementById('ioField').value;
        if(!val) return;
        const data = JSON.parse(val);
        startGeneration(true);
        simulations.forEach(s => {
            s.chaser.dna = [...data.c];
            s.evader.dna = [...data.e];
        });
    };

    startGeneration(true);
    loop();
    </script>
</body>
</html>
