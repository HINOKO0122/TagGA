<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>GA Tag Simulation - Data IO Version</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; overflow: hidden; }
        .controls { padding: 20px; text-align: center; background: #333; width: 100%; box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 10; }
        #container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 20px; overflow-y: auto; max-height: 70vh; }
        canvas { background: #000; border: 1px solid #555; width: 150px; height: 150px; }
        button { cursor: pointer; padding: 8px 15px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 4px; }
        button:focus { outline: none; }
        #info { font-size: 1.2em; margin: 10px; font-family: monospace; color: #0f0; }
        .io-area { margin-top: 10px; }
        input { padding: 8px; width: 300px; background: #111; color: #0f0; border: 1px solid #444; font-family: monospace; font-size: 0.8em; }
    </style>
</head>
<body>
    <div class="controls">
        <h1>GA 鬼ごっこ (遺伝データ保存機能付)</h1>
        <div id="info">世代: 0 | 待機中</div>
        <div>
            <button id="startBtn">リセットして開始</button>
            <button id="playerChaserBtn">鬼として参戦</button>
            <button id="playerEvaderBtn">逃走者として参戦</button>
            <button id="cancelPlayerBtn" style="background: #622;">参戦解除</button>
        </div>
        <div class="io-area">
            <input type="text" id="ioField" placeholder="ここにDNAデータが出力/入力されます">
            <button id="exportBtn" style="background: #446;">データ出力</button>
            <button id="importBtn" style="background: #464;">データ読込</button>
        </div>
    </div>
    <div id="container"></div>

    <script>
    const ROOM_SIZE = 200;
    const SIM_COUNT = 25;
    const DURATION_SEC = 10;
    const FPS = 30;
    const TOTAL_FRAMES = DURATION_SEC * FPS;
    const DNA_LENGTH = 10; 

    let isPlayerMode = false;
    let playerRole = null;

    class Agent {
        constructor(x, y, dna) {
            this.x = x; this.y = y;
            this.dirIndex = 0;
            this.warpCooldown = 0;
            this.dna = dna ? [...dna] : Array.from({ length: DNA_LENGTH }, () => Math.random() * 2 - 1);
            this.score = 0;
            this.isAlive = true;
            this.warpLines = [];
        }
        get angle() { return this.dirIndex * (Math.PI / 2); }
    }

    class Simulation {
        constructor(container, chaserDNA, evaderDNA, isMain = false) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = ROOM_SIZE;
            this.canvas.height = ROOM_SIZE;
            container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.isMain = isMain;
            this.chaser = new Agent(Math.random()*160+20, Math.random()*160+20, chaserDNA);
            this.evader = new Agent(Math.random()*160+20, Math.random()*160+20, evaderDNA);
            this.frame = 0;
        }

        getLogicalDir(ent, target, isChaser) {
            const dx = target.x - ent.x;
            const dy = target.y - ent.y;
            let preferredDirs = [];
            if (isChaser) {
                if (Math.abs(dx) > Math.abs(dy)) preferredDirs = dx > 0 ? [0, 1, 3, 2] : [2, 1, 3, 0];
                else preferredDirs = dy > 0 ? [1, 0, 2, 3] : [3, 0, 2, 1];
            } else {
                if (Math.abs(dx) > Math.abs(dy)) preferredDirs = dx > 0 ? [2, 1, 3, 0] : [0, 1, 3, 2];
                else preferredDirs = dy > 0 ? [3, 0, 2, 1] : [1, 0, 2, 3];
            }
            for (let dir of preferredDirs) {
                let nextX = ent.x + Math.cos(dir * Math.PI/2) * 10;
                let nextY = ent.y + Math.sin(dir * Math.PI/2) * 10;
                if (nextX > 5 && nextX < ROOM_SIZE-5 && nextY > 5 && nextY < ROOM_SIZE-5) return dir;
            }
            return preferredDirs[0];
        }

        update(keys) {
            if (!this.chaser.isAlive || this.frame >= TOTAL_FRAMES) return;

            [this.chaser, this.evader].forEach((ent, idx) => {
                const isChaser = idx === 0;
                const target = isChaser ? this.evader : this.chaser;
                let doWarp = false;
                ent.warpLines = ent.warpLines.filter(l => { l.life--; return l.life > 0; });

                if (this.isMain && isPlayerMode && playerRole === (isChaser ? 'chaser' : 'evader')) {
                    if (keys.has('arrowright') || keys.has('d')) ent.dirIndex = 0;
                    else if (keys.has('arrowdown') || keys.has('s')) ent.dirIndex = 1;
                    else if (keys.has('arrowleft') || keys.has('a')) ent.dirIndex = 2;
                    else if (keys.has('arrowup') || keys.has('w')) ent.dirIndex = 3;
                    if (keys.has(' ')) doWarp = true;
                } else {
                    ent.dirIndex = this.getLogicalDir(ent, target, isChaser);
                    const dirFlags = [0,0,0,0]; dirFlags[ent.dirIndex] = 1;
                    const inputs = [ent.x/200, ent.y/200, target.x/200, target.y/200, ...dirFlags, ent.warpCooldown === 0 ? 1 : 0, (TOTAL_FRAMES-this.frame)/TOTAL_FRAMES];
                    let s = 0; for(let j=0; j<10; j++) s += inputs[j] * ent.dna[j];
                    if (s > 1.5) doWarp = true;
                }

                if (doWarp && ent.warpCooldown === 0) {
                    const ox = ent.x, oy = ent.y;
                    ent.x += Math.cos(ent.angle) * 70; ent.y += Math.sin(ent.angle) * 70;
                    ent.warpCooldown = 30;
                    ent.warpLines.push({ x1: ox, y1: oy, x2: ent.x, y2: ent.y, life: 20 });
                } else {
                    ent.x += Math.cos(ent.angle) * 5; ent.y += Math.sin(ent.angle) * 5;
                }
                ent.x = Math.max(5, Math.min(ROOM_SIZE-5, ent.x));
                ent.y = Math.max(5, Math.min(ROOM_SIZE-5, ent.y));
                if (ent.warpCooldown > 0) ent.warpCooldown--;
            });

            const dist = Math.hypot(this.chaser.x - this.evader.x, this.chaser.y - this.evader.y);
            if (dist < 12) {
                this.chaser.isAlive = false;
                this.chaser.score = 3000 + (TOTAL_FRAMES - this.frame);
                this.evader.score = this.frame;
            }
            this.frame++;
            if (this.frame >= TOTAL_FRAMES && this.chaser.isAlive) {
                this.chaser.score = Math.max(0, 500 - dist);
                this.evader.score = 1000 + dist;
            }
            this.draw();
        }

        draw() {
            const ctx = this.ctx;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);
            if (this.isMain && isPlayerMode) {
                ctx.strokeStyle = playerRole === 'chaser' ? 'red' : '#0ff';
                ctx.lineWidth = 4; ctx.strokeRect(0, 0, ROOM_SIZE, ROOM_SIZE);
            }
            [this.chaser, this.evader].forEach((ent, idx) => {
                const color = idx === 0 ? '#f44' : '#0ff';
                ent.warpLines.forEach(l => {
                    ctx.beginPath(); ctx.strokeStyle = `rgba(255,255,0,${l.life/20})`;
                    ctx.lineWidth = 2; ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
                });
                ctx.fillStyle = color;
                ctx.save(); ctx.translate(ent.x, ent.y); ctx.rotate(ent.angle);
                ctx.fillRect(-5, -5, 14, 10);
                if (ent.warpCooldown === 0) { ctx.strokeStyle = 'white'; ctx.strokeRect(-7, -7, 18, 14); }
                ctx.restore();
            });
            if (!this.chaser.isAlive) { ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.strokeRect(0,0, ROOM_SIZE, ROOM_SIZE); }
        }
    }

    let simulations = [];
    let generation = 0;
    const keys = new Set();
    const container = document.getElementById('container');
    const infoDisp = document.getElementById('info');
    const ioField = document.getElementById('ioField');

    window.addEventListener('keydown', e => { if (e.key === ' ') e.preventDefault(); keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    function startGeneration(isNew = false, fixedDNA = null) {
        let nextC = [], nextE = [];
        if (fixedDNA) {
            for(let i=0; i<SIM_COUNT; i++) {
                nextC.push([...fixedDNA.chaser]);
                nextE.push([...fixedDNA.evader]);
            }
            generation = 1;
        } else if (!isNew && simulations.length > 0) {
            const sortedC = simulations.map(s => s.chaser).sort((a,b) => b.score - a.score);
            const sortedE = simulations.map(s => s.evader).sort((a,b) => b.score - a.score);
            for(let i=0; i<SIM_COUNT; i++) {
                const pC = sortedC[Math.floor(Math.random()*5)].dna;
                const pE = sortedE[Math.floor(Math.random()*5)].dna;
                nextC.push(pC.map(v => v + (Math.random()*0.4 - 0.2)));
                nextE.push(pE.map(v => v + (Math.random()*0.4 - 0.2)));
            }
            generation++;
        } else {
            generation = 1;
        }
        container.innerHTML = '';
        simulations = [];
        for (let i = 0; i < SIM_COUNT; i++) {
            simulations.push(new Simulation(container, nextC[i], nextE[i], i === 0));
        }
    }

    function loop() {
        if (simulations.length > 0) {
            simulations.forEach(sim => sim.update(keys));
            infoDisp.innerText = `世代: ${generation} | 残り時間: ${(Math.max(0, (TOTAL_FRAMES-simulations[0].frame)/FPS)).toFixed(1)}s ${isPlayerMode ? '(参戦中)' : ''}`;
            if (simulations.every(s => s.frame >= TOTAL_FRAMES || !s.chaser.isAlive)) startGeneration();
        }
        requestAnimationFrame(loop);
    }

    document.querySelectorAll('button').forEach(b => b.addEventListener('click', () => b.blur()));
    document.getElementById('startBtn').onclick = () => { isPlayerMode = false; startGeneration(true); };
    document.getElementById('playerChaserBtn').onclick = () => { isPlayerMode = true; playerRole = 'chaser'; };
    document.getElementById('playerEvaderBtn').onclick = () => { isPlayerMode = true; playerRole = 'evader'; };
    document.getElementById('cancelPlayerBtn').onclick = () => { isPlayerMode = false; playerRole = null; };

    // インポート・エクスポート
    document.getElementById('exportBtn').onclick = () => {
        if (simulations.length === 0) return;
        const data = {
            chaser: simulations[0].chaser.dna,
            evader: simulations[0].evader.dna,
            gen: generation
        };
        ioField.value = JSON.stringify(data);
        ioField.select();
        alert("DNAデータをコピーしました。メモ帳などに保存してください。");
    };

    document.getElementById('importBtn').onclick = () => {
        try {
            const data = JSON.parse(ioField.value);
            if (data.chaser && data.evader) {
                isPlayerMode = false;
                startGeneration(true, data);
                generation = data.gen || 1;
                alert("DNAデータを読み込みました。第" + generation + "世代から再開します。");
            }
        } catch(e) {
            alert("データの形式が正しくありません。");
        }
    };

    startGeneration(true);
    loop();
    </script>
</body>
</html>
