<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>GA Tag Simulation - Logic Move Version</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; overflow: hidden; }
        .controls { padding: 20px; text-align: center; background: #333; width: 100%; box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 10; }
        #container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; padding: 20px; overflow-y: auto; max-height: 80vh; }
        canvas { background: #000; border: 1px solid #555; width: 150px; height: 150px; }
        button { cursor: pointer; padding: 8px 15px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 4px; }
        button:focus { outline: none; }
        #info { font-size: 1.2em; margin: 10px; font-family: monospace; color: #0f0; }
    </style>
</head>
<body>
    <div class="controls">
        <h1>GA 鬼ごっこ (移動ロジック固定・ワープのみ進化)</h1>
        <div id="info">世代: 0 | 待機中</div>
        <button id="startBtn">リセットして開始</button>
        <button id="playerChaserBtn">鬼として参戦</button>
        <button id="playerEvaderBtn">逃走者として参戦</button>
        <button id="cancelPlayerBtn" style="background: #622;">参戦解除</button>
    </div>
    <div id="container"></div>

    <script>
    const ROOM_SIZE = 200;
    const SIM_COUNT = 25;
    const DURATION_SEC = 10;
    const FPS = 30;
    const TOTAL_FRAMES = DURATION_SEC * FPS;
    // DNAはワープ判断用（入力10に対する重み1セットのみ）
    const DNA_LENGTH = 10; 

    let isPlayerMode = false;
    let playerRole = null;

    class Agent {
        constructor(x, y, dna) {
            this.x = x; this.y = y;
            this.dirIndex = 0; // 0:右, 1:下, 2:左, 3:上
            this.warpCooldown = 0;
            this.dna = dna || Array.from({ length: DNA_LENGTH }, () => Math.random() * 2 - 1);
            this.score = 0;
            this.isAlive = true;
            this.warpLines = [];
        }
        get angle() { return this.dirIndex * (Math.PI / 2); }
    }

    class Simulation {
        constructor(container, chaserDNA, evaderDNA, isMain = false) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = ROOM_SIZE;
            this.canvas.height = ROOM_SIZE;
            container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.isMain = isMain;
            this.chaser = new Agent(Math.random()*180+10, Math.random()*180+10, chaserDNA);
            this.evader = new Agent(Math.random()*180+10, Math.random()*180+10, evaderDNA);
            this.frame = 0;
        }

        // --- ロジックに基づいた移動方向の決定 ---
        getLogicalDir(ent, target, isChaser) {
            const dx = target.x - ent.x;
            const dy = target.y - ent.y;
            
            let preferredDirs = [];
            if (isChaser) {
                // 鬼：近づく方向を優先
                if (Math.abs(dx) > Math.abs(dy)) preferredDirs = dx > 0 ? [0, 1, 3, 2] : [2, 1, 3, 0];
                else preferredDirs = dy > 0 ? [1, 0, 2, 3] : [3, 0, 2, 1];
            } else {
                // 逃走者：遠ざかる方向を優先
                if (Math.abs(dx) > Math.abs(dy)) preferredDirs = dx > 0 ? [2, 1, 3, 0] : [0, 1, 3, 2];
                else preferredDirs = dy > 0 ? [3, 0, 2, 1] : [1, 0, 2, 3];
            }

            // 壁にぶつかる場合は次の候補を選ぶ（壁伝い移動）
            for (let dir of preferredDirs) {
                let nextX = ent.x + Math.cos(dir * Math.PI/2) * 10;
                let nextY = ent.y + Math.sin(dir * Math.PI/2) * 10;
                if (nextX > 5 && nextX < ROOM_SIZE-5 && nextY > 5 && nextY < ROOM_SIZE-5) {
                    return dir;
                }
            }
            return preferredDirs[0];
        }

        update(keys) {
            if (!this.chaser.isAlive || this.frame >= TOTAL_FRAMES) return;

            [this.chaser, this.evader].forEach((ent, idx) => {
                const isChaser = idx === 0;
                const target = isChaser ? this.evader : this.chaser;
                let doWarp = false;

                ent.warpLines = ent.warpLines.filter(line => { line.life--; return line.life > 0; });

                // 移動方向の決定（ロジック）
                if (this.isMain && isPlayerMode && playerRole === (isChaser ? 'chaser' : 'evader')) {
                    if (keys.has('arrowright') || keys.has('d')) ent.dirIndex = 0;
                    else if (keys.has('arrowdown') || keys.has('s')) ent.dirIndex = 1;
                    else if (keys.has('arrowleft') || keys.has('a')) ent.dirIndex = 2;
                    else if (keys.has('arrowup') || keys.has('w')) ent.dirIndex = 3;
                    if (keys.has(' ')) doWarp = true;
                } else {
                    ent.dirIndex = this.getLogicalDir(ent, target, isChaser);
                    
                    // AIはワープするかどうかだけを考える
                    const dirFlags = [0,0,0,0]; dirFlags[ent.dirIndex] = 1;
                    const inputs = [
                        ent.x/200, ent.y/200, target.x/200, target.y/200, 
                        ...dirFlags, ent.warpCooldown === 0 ? 1 : 0, (TOTAL_FRAMES-this.frame)/TOTAL_FRAMES
                    ];
                    let score = 0;
                    for(let j=0; j<10; j++) score += inputs[j] * ent.dna[j];
                    if (score > 1.5) doWarp = true;
                }

                const speed = 5;
                if (doWarp && ent.warpCooldown === 0) {
                    const oldX = ent.x; const oldY = ent.y;
                    ent.x += Math.cos(ent.angle) * 70;
                    ent.y += Math.sin(ent.angle) * 70;
                    ent.warpCooldown = 30;
                    ent.warpLines.push({ x1: oldX, y1: oldY, x2: ent.x, y2: ent.y, life: 20 });
                } else {
                    ent.x += Math.cos(ent.angle) * speed;
                    ent.y += Math.sin(ent.angle) * speed;
                }

                ent.x = Math.max(5, Math.min(ROOM_SIZE-5, ent.x));
                ent.y = Math.max(5, Math.min(ROOM_SIZE-5, ent.y));
                if (ent.warpCooldown > 0) ent.warpCooldown--;
            });

            const dist = Math.hypot(this.chaser.x - this.evader.x, this.chaser.y - this.evader.y);
            if (dist < 12) {
                this.chaser.isAlive = false;
                this.chaser.score = 3000 + (TOTAL_FRAMES - this.frame);
                this.evader.score = this.frame;
            }
            this.frame++;
            if (this.frame >= TOTAL_FRAMES && this.chaser.isAlive) {
                this.chaser.score = Math.max(0, 500 - dist);
                this.evader.score = 1000 + dist;
            }
            this.draw();
        }

        draw() {
            const ctx = this.ctx;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ROOM_SIZE, ROOM_SIZE);

            if (this.isMain && isPlayerMode) {
                ctx.strokeStyle = playerRole === 'chaser' ? 'red' : '#0ff';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, ROOM_SIZE, ROOM_SIZE);
            }

            [this.chaser, this.evader].forEach((ent, idx) => {
                const color = idx === 0 ? '#ff4444' : '#00ffff';
                ent.warpLines.forEach(line => {
                    ctx.beginPath(); ctx.strokeStyle = `rgba(255, 255, 0, ${line.life / 20})`;
                    ctx.lineWidth = 3; ctx.moveTo(line.x1, line.y1); ctx.lineTo(line.x2, line.y2); ctx.stroke();
                });
                ctx.fillStyle = color;
                ctx.save();
                ctx.translate(ent.x, ent.y);
                ctx.rotate(ent.angle);
                ctx.fillRect(-5, -5, 14, 10); // 進行方向をわかりやすく
                if (ent.warpCooldown === 0) {
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(-7, -7, 18, 14);
                }
                ctx.restore();
            });
            if (!this.chaser.isAlive) {
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect(0,0, ROOM_SIZE, ROOM_SIZE);
            }
        }
    }

    let simulations = [];
    let generation = 0;
    const keys = new Set();
    const container = document.getElementById('container');
    const infoDisp = document.getElementById('info');

    window.addEventListener('keydown', e => {
        if (e.key === ' ') e.preventDefault();
        keys.add(e.key.toLowerCase());
    });
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    function startGeneration(isNew = false) {
        let nextChaserDNAs = [];
        let nextEvaderDNAs = [];

        if (!isNew && simulations.length > 0) {
            const sortedC = simulations.map(s => s.chaser).sort((a,b) => b.score - a.score);
            const sortedE = simulations.map(s => s.evader).sort((a,b) => b.score - a.score);
            for(let i=0; i<SIM_COUNT; i++) {
                const pC = sortedC[Math.floor(Math.random()*5)].dna;
                const pE = sortedE[Math.floor(Math.random()*5)].dna;
                nextChaserDNAs.push(pC.map(v => v + (Math.random()*0.4 - 0.2)));
                nextEvaderDNAs.push(pE.map(v => v + (Math.random()*0.4 - 0.2)));
            }
            generation++;
        } else if (isNew) {
            generation = 1;
        }

        container.innerHTML = '';
        simulations = [];
        for (let i = 0; i < SIM_COUNT; i++) {
            simulations.push(new Simulation(container, nextChaserDNAs[i], nextEvaderDNAs[i], i === 0));
        }
    }

    function loop() {
        if (simulations.length > 0) {
            simulations.forEach(sim => sim.update(keys));
            const main = simulations[0];
            infoDisp.innerText = `世代: ${generation} | 残り時間: ${(Math.max(0, (TOTAL_FRAMES-main.frame)/FPS)).toFixed(1)}s ${isPlayerMode ? '(参戦中)' : ''}`;
            if (simulations.every(s => s.frame >= TOTAL_FRAMES || !s.chaser.isAlive)) {
                startGeneration();
            }
        }
        requestAnimationFrame(loop);
    }

    document.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => btn.blur()));
    document.getElementById('startBtn').onclick = () => { isPlayerMode = false; startGeneration(true); };
    document.getElementById('playerChaserBtn').onclick = () => { isPlayerMode = true; playerRole = 'chaser'; };
    document.getElementById('playerEvaderBtn').onclick = () => { isPlayerMode = true; playerRole = 'evader'; };
    document.getElementById('cancelPlayerBtn').onclick = () => { isPlayerMode = false; playerRole = null; };

    startGeneration(true);
    loop();
    </script>
</body>
</html>
